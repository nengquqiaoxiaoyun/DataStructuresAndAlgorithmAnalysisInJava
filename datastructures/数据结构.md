该笔记参考书籍数据结构与算法分析以及浙大数据结构

### 抽象数据类型

抽象数据类型是带有**一组操作**的一些**对象**的集合

- 数据对象集
- 对于对象集的一组操作

### 表

#### 线性表

线性表是由**同类数据元素**构成**有序序列**的线性结构

- 表中元素的个数称为线性表的*长度*
- 线性表没有元素时称为*空表*
- 表起始位置称为*表头*，结束为止称为*表尾*

#### 表的简单数组实现

对表的所有操作都可以通过数组实现

以下程序解释一个数组在必要时如何被扩展

```java
int[] arr = new int[10];
	...
// 扩大arr
int[] newArr = new int[arr.length * 2];
for (int i = 0; i < arr.length; i++) {
     newArr[i] = arr[i];
}
arr = newArr;
```

数组的实现使得 `printList`以线性时间被执行` O(n)` ，`findKth`花费常数时间。而插入和删除的花费需要昂贵的开销，这取决于插入和删除的位置。最坏情况下，插入到0的位置需要移动整个数组，删除第一个元素需要移动整个数组，所以这两个的最坏情况为` O(n)`，如果所有的操作都发生在表的高端（末尾），则花费常数时间。

如果只发生对数组的访问，数组是表的一种恰当的实现，如果是对表进行插入或删除，尤其是对表的前端进行操作，那么数组就不是一种好的选择。

### 简单链表

**不要求逻辑上相邻的两个元素物理上也相连**，通过链建立起数据元素之间的逻辑关系
https://www.zhihu.com/question/21318658/answer/63652147

为了避免插入和删除的线性开销，我们需要保证表可以**不连续存储**，否则**表的每个部分可能都需要整体移动**

链表由一系列节点组成，这些节点不必在内存中相连。每一个节点表元素以及包含该元素到后继节点的链(link)，称之为next链，最后一个节点的`next`链引用为`null`

为了执行`printList`需要从表的第一个节点开始用后继的`next`链遍历，这种操作是线性的

`remove`需要修改下一个`next`引用来完成

![image-20200304104657308](assets/image-20200304104657308.png)

`insert` 需要使用`new`操作符从系统取得一个新节点，此后执行两次引用的调整

![image-20200304104840162](assets/image-20200304104840162.png)

插入和删除操作，找到某个元素时间为线性，执行操作时间为常数，对于第一个元素的删除和插入时间为常数

### ArrayList

`ArrayList`的底层是数组，这意味着`get`和`set`将花费常数时间，`add`和`remove`将花费线性时间，如果是最后一个元素则花费常数时间

### LinkedList

`LinkedList`提供了对表头及表尾的操作，这意味着它对于表头表尾的操作只花费常数时间，对于非表头的插入和删除仍花费线性时间，**对于已知位置的插入和删除只花费常数时间**

`LinkedList`的缺点是不容易做索引，对于`get`将花费线性时间，除非调用非常接近表的断点，对于接近表后部的项，搜索可以从表的后部开始

### 复杂度分析

```java
public static void makeList(List<Integer> list) {
        list.clear();
        for (int i = 0; i < N; i++) {
            // 在表尾进行添加
            list.add(i);
        }
    }
```

不管是`ArrayList`还是`LinkedList`作为参数，`makeList`的运行时间为`O(N)`，如果在表的前端进行添加一些项来构造一个`List`:

```java
public static void makeList(List<Integer> list) {
    list.clear();
    for (int i = 0; i < N; i++) {
        // 在表头进行添加
        list.add(0, i);
    }
}
```

对于`LinkedList`它的运行时间为`O(N)`，对于`ArrayList`其运行时间为`O(N²)`

```java
public static int sum(List<Integer> list) {
    int total = 0;
    for (int i = 0; i < N; i++) {
        total += list.get(i);
    }
    return total;
}
```

该方法计算`List`中的数的和，对于`ArrayList`的运行时间为`O(N)`，但对于`LinkedList`来说其运行时间则是`O(N²)`

#### remove

对于`ArrayList`，`remove`几乎是一个失败策略，因为从一个`ArrayList`的几乎任意位置进行删除都是昂贵的操作。不过在`LinkedList`中却存在某种希望，因为从已知位置的删除操作都可以通过重新安排某些链而被有效地完成。

以下的例子我们试图删除偶数值

```java
public static void removeEvensVer(List<Integer> list) {
    int i = 0;
    // array\linked都是线性
    while (i < list.size()) {
        // array 为常数 linked线性
        if (list.get(i) % 2 == 0)
            // array 线性 linked线性
            list.remove(i);
        else
            i++;
    }
}
```

对于`ArrayList`，`remove`的效率不是很高，它的运行时间为`O(N²)`，对于`LinkedList`则为三次。下面提供一种矫正的思路

```java
public static void removeEvensVer1(List<Integer> list) {
    for (Integer x : list) {
        if (x % 2 == 0)
            list.remove(x);
    }
}
```

使用一个增强的`for`循环，这样就省出了`get`的时间，但是运行这个程序将会产生一个异常`ConcurrentModificationException`，因为当一项被删除时，由增强的`for`循环所使用的基础迭代器是非法的  

 [原因](<https://www.jianshu.com/p/c5b52927a61a>)

```java
public static void removeEvensVer(List<Integer> list) {
        Iterator<Integer> iterator = list.iterator();
        while (iterator.hasNext()) {
            if (iterator.next() % 2 == 0)
                iterator.remove();
        }
    }
```

在迭代器找到一个偶数值之后，我们可以使用该迭代器来删除这个值。对于`LinkedList`而言，对该迭代器的`remove`方法的调用只花费常数时间，因为该迭代器位于需要被删的节点。因此对于`LinkedList`，整个程序花费线性时间，而`ArrayList`则花费二次时间

### ArrayList的实现

